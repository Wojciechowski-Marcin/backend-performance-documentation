% !TeX root = ./0Base.tex

\chapter{Results}\label{cha:results}

\section{Performance}

Graphs below (\ref{tab:resultsGet}, \ref{tab:resultsGetMany}, \ref{tab:resultsDelete}, \ref{tab:resultsPost} and \ref{tab:resultsPut}) show an average response time in milliseconds by number of concurrent \acrshort{vu}s from the tests mentioned in previous chapters. To better show the results of the tests, on vertical axis a logarithmic scale has been used, as Django had very long response times in comparison to other two frameworks. Under each graph there is a table with data used to draw the mentioned graphs - average response times rounded to second decimal place. As seen on the results, in cases with small amount concurrent requests Express.js application was the fastest. Starting from 32 \acrlong{vu}s for get requests, 128 for post and put requests and 512 for getMany ASP.NET Core has faster results. The trend line in all charts (except for delete tests, where ASP.NET is slower than express in all tests by from 8\% to 49\% depending on concurrency) shows that Express.js handles bigger loads worse than ASP.NET. In most tests Django stands out very far from the others, being even up to almost 17 times slower (for get tests with 8 concurrency) than the opponents. This framework surprised on getMany tests, where it was slower by only 15\% than the second best result - ASP.NET.

\input{figures/resultsGet.tex}
\input{tables/resultsGet.tex}

\input{figures/resultsGetMany.tex}
\input{tables/resultsGetMany.tex}

\input{figures/resultsDelete.tex}
\input{tables/resultsDelete.tex}

\input{figures/resultsPost.tex}
\input{tables/resultsPost.tex}

\input{figures/resultsPut.tex}
\input{tables/resultsPut.tex}

\section{Security}
\subsection{Security Misconfiguration}
\subsubsection{Django specific variables}
Django has one configuration file, generated automatically at the project creation. At the starting lines of settings.py a few important variables and comments are placed (listing \ref{lst:djangoSettings}).
\input{listings/djangoSettings.tex}.
As we can see, the creators of Django clearly want the developers to prevent some security vulnerabilities, by placing \lstinline{SECURITY WARNING} comments above two crucial variables - \lstinline{SECRET_KEY} and \lstinline{DEBUG}.
\lstinline{SECRET_KEY} is used in:
\begin{itemize}
    \item Generating session tokens
    \item Generating password reset tokens
    \item Ensuring that data passed from django forms is not changed
    \item Generating secret URLs for temporary access to a protected resource (for example a file)
    \item And any other cryptographic signing, unless a developer provides a different key
          % TODO ref https://docs.djangoproject.com/en/3.2/ref/settings/#secret-key 
          %  https://docs.djangoproject.com/en/3.2/topics/signing/
\end{itemize}.
All of them are very serious risks and should be avoided by any means. App created for this research is tiny does not have any serious logic other than working on a database model, so cryptographic signing is not used at all. For any commercial applications leaking this variable could cause a lot of harm.
The second risky variable - \lstinline{DEBUG} - is responsible for turning on and off a debug mode. When set to True, whenever an error happens Django will display a detailed traceback, including parts of the applications source code and environment variables (such as Django settings).
Django developers thought about it being a little secure in case of accidental leakage by excluding from the message variables containing the following strings:
\begin{itemize}
    \item API,
    \item KEY,
    \item PASS,
    \item SECRET,
    \item SIGNATURE,
    \item TOKEN.
\end{itemize}
\input{figures/djangoStackTrace.tex}
\input{figures/djangoRequestDetails.tex}

Third important variable that cannot be forgotten is \lstinline{ALLOWED_HOSTS} (without \lstinline{SECURITY WARNING} comment, as it is set to an empty array by default). This variable is meant to be a list of strings presenting host names that Django can send responses to. If a given host is not on the list and tries to request a resource, response with status 400 is sent immediately. When \lstinline{DEBUG} is set to True and this variable is empty, the only way to get response from the app is by requesting localhost.

To help the developers, Django offers a command \lstinline{python3 manage.py check --deploy} command. It includes a few essential steps to prepare the environment for production without security risks.
\input{listings/djangoCheckDeploy.tex}

\subsubsection{Common problems}
There are a few things to remember when releasing any application to the world.
\begin{enumerate}
    \item Always use newest versions of frameworks and packages.

          Every external dependency that is brought to the project may be adding an additional vulnerability to the application. That is what vulnerability databases were created for - when someone discovers a problem in a given software it is often added to a list including vulnerability description and version of the faulty package. Snyk can be an example of a vulnerability \acrshort{db}.
          % TODO ref https://snyk.io/vuln/

    \item Do not configure the application to run as root

          This opens a window for the attacker to run malicious scripts or starting new child processes on a server.

    \item Limit request body size

          With unlimited sizes in body the server can be repetitively requested with large input payload, which could cause a server crash through running out of memory or keeping the processor busy.
          % TODO ref https://nodegoat.herokuapp.com/tutorial/a5
\end{enumerate}

\subsection{Injection}
Prepared applications were tested with user creation requests containing malicious \acrshort{sql} statements. Request body was prepared based on logs shown in \ref{lst:sqlPost} to check if the input string could be terminated and any other \acrshort{sql} statement could be executed.
\input{figures/injectionRequest.tex}

\acrshort{sql} logs of the requests are placed in listings \ref{lst:aspnetInjectionLog}, \ref{lst:expressInjectionLog} and \ref{lst:djangoInjectionLog}. As shown, the characters that could cause the harm in this case are escaped (single quotes are doubled) in all applications.
\input{listings/aspnetInjectionLog.tex}
\input{listings/expressInjectionLog.tex}
\input{listings/djangoInjectionLog.tex}

Further research shown that the \acrshort{sql} injection can happen in these frameworks with careless developers. All applications provide functions which allow to perform raw \acrshort{sql} queries on the database. If a developer uses this function in the code and forgets to escape variables that include the user input results in an application that could be easily exploited.
% DJANGO
% https://hdivsecurity.com/sql-injection-prevention
% TODO ref https://docs.djangoproject.com/en/3.2/topics/security/#sql-injection-protection
% TODO ref https://docs.djangoproject.com/en/3.2/topics/db/sql/#executing-raw-queries

\subsection{Insufficient Logging}
\subsubsection{Django}
\subsubsection{ASP.NET}
\subsubsection{Express.js}
% DJANGO
% https://docs.djangoproject.com/en/3.0/topics/logging/
% https://pypi.org/project/django-automated-logging/
% https://pypi.org/project/django-log-viewer/
% When your application has insufficient logging and monitoring, attacks and suspicious activity can go unnoticed. By default, Django uses the Python native logging module for system logging. 
% django.security.* logging messages.

% ASPNET
% https://www.infoq.com/presentations/owasp-top-10-vulnerabilities-2017/
