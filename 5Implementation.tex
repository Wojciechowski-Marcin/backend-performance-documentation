% !TeX root = ./0Base.tex

\chapter{Implementation}

%
% DOCKER
%
\section{Docker and Docker Compose}

% TODO it was written for django, change accordingly to the current section

The Dockerfile that I prepared was inspired by Anuj Sharma, who created one for his series of Django development guide articles.
% TODO ref https://dev.to/anujdev/django-development-using-docker-as-host-part-1-dockerfile-3bnc
It uses the python:3.9.1-slim image, installs all necessary packages, places the code in suitable folders, changes the user to a non-root user and sets the entrypoint to a script that starts the application.
Docker Compose configuration contains the build folder, imports the environment variables for connection with \acrshort{pg} and variable with amount of users to create, ensures that the application starts after the database has started (makes the app wait for \acrlong{pg} healthcheck) and reserves memory for the application.

%
% DJANGO
%
\section{Django}
\subsection{Model}
Django offers a built in User model, however it was decided not to use it in this case. The reason for that is that the built in model handles extra operations for the User, like creating groups, permissions, authentication and a few additional fields. Instead of using it, the implementation of model presented in listing \ref{lst:djangoModel} was created. It does not contain the primary key definition, as django.db.models.Model class handles it automatically.
\input{listings/djangoModel.tex}

\subsection{Database connection and initialization}
Django handles a lot of things for the user - connection is very simple - in initial project generation a file settings.py is created, which consists of all the necessary variables for the system to work. In the file we can find a variable named Databases, initially with SQLite backend. All that needs to be done to connect to our \acrlong{pg} is to change the engine to built-in \acrshort{pg} backend and change the remaining fields - name, user, password, host and port, as presented in listing \ref{lst:djangoDbConn}. With that done, the connection is automatically done on the system startup.
\input{listings/djangoDbConnection.tex}
Creating the table is handled by migration system - to create the migrations the command from listing \ref{lst:djangoMakeMigrations} had to be run.
\input{listings/djangoMakeMigrations.tex}
This creates the tables based on the model presented in models.py files through the whole project. In this case, it only created one table.
For creating the initial population a management function was prepared, that is being executed from the main script. Seeding the database was presented in listing \ref{lst:djangoSeedDb}.
\input{listings/djangoSeedDb.tex}

\subsection{Routing and serialization}
Django routing is to be placed in urls.py files. There is one main file in the project configuration folder, and one in each module. Since this application consists of only one modules, two urls.py files exist - presented in listings \ref{lst:djangoUrlsConfig} and \ref{lst:djangoUrlsApp}.
\input{listings/djangoUrlsConfig.tex}
\input{listings/djangoUrlsApp.tex}
Serialization is another great thing about Django and \acrlong{drf} - \acrshort{drf} has built in abstract ModelSerializer class - to create a serializer for our model, all that needs to be done is to specify which model and which fields we want to serialize, as presented in listing \ref{lst:djangoSerialization}.
\input{listings/djangoSerialization.tex}

\subsection{Endpoints}
It is pretty certain at this point that django offers a lot of functionality. It should come with no surprise that the endpoints can also be implemented with a few lines of code, thanks to the built in methods. As shown in the listing \ref{lst:djangoViews}, creating views does not require much, only the queryset containing all user models and a serializer class.  With this ViewSet and one standalone function we get all the endpoints described in section \ref{sec:endpoints} of this document. UserViewSet class was used in the routing in file presented in listing \ref{lst:djangoUrlsApp}.
\input{listings/djangoViews.tex}

%
% EXPRESS
%
\section{Express}
\subsection{Model}
User model in express.js needs to contain all the necessary logic for handling \acrshort{crud} operations. Implementation of the model is shown in listing \ref{lst:expressModel} - it shows all \acrshort{sql} statements except include, which is placed in separate file. Database queries return \acrshort{json} object that is ready to be
\input{listings/expressModel.tex}

\subsection{Database connection and initialization}
Work with express is a bit more difficult, as most of the configuration needs to be done by the user. To connect with the database, a postgres promise instance needs to be created. Because there is no migration system, creating the table also needs to be done manually. To do so, a database configuration file was created (listing \ref{lst:expressDbConnection}) and imported into the entrypoint file. It contains all the necessary information about the connection and creation of the table.
\input{listings/expressDbConnection.tex}
Initialization of the database is handled by function presented in listing \ref{lst:expressSeedDb}.
\input{listings/expressSeedDb.tex}

\subsection{Routing and endpoints}
Unlike in Django, routes and endpoints are not separated in two files. It is very common to keep them in a single file, as shown in listing \ref{lst:expressEndpoints}. All they do is registering a route on the provided path in the first argument and executing the functions provided in the second argument. The mentioned functions call the respective method from User model sends appropriate response based on the return data of the query.
\input{listings/expressEndpoints.tex}

%
% ASP.NET
%
\section{ASP.NET}


%
% PERFORMANCE
%
\section{Performance tests}
